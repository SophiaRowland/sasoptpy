proc optmodel;
   set <str> INPUTS;
   read data INPUT_DATA into INPUTS=[input] ;
   set <str> OUTPUTS;
   read data OUTPUT_DATA into OUTPUTS=[output] ;
   set GARAGES;
   str garage_name {GARAGES};
   num input {INPUTS, GARAGES};
   num output {OUTPUTS, GARAGES};
   read data GARAGE_DATA into GARAGES=[_N_] garage_name {i in INPUTS} < input[i, _N_]=col(i) > {i in OUTPUTS} < output[i, _N_]=col(i) >;
   num k;
   num efficiency_number {GARAGES};
   num weight_sol {GARAGES, GARAGES};
   var Weight {{GARAGES}} >= 0;
   var Inefficiency >= 0;
   max Objective = Inefficiency;
   con input_con {o21 in INPUTS} : input[o21, k] - (sum {j in GARAGES} (input[o21, j] * Weight[j])) >= 0;
   con output_con {o33 in OUTPUTS} : sum {j in GARAGES} (output[o33, j] * Weight[j]) - output[o33, k] * Inefficiency >= 0;
   cofor {o46 in GARAGES} do;
      k = o46;
      solve;
      efficiency_number[k] = (1) / (Inefficiency.sol);
      for {o58 in GARAGES} do;
         if Weight[o58].sol > 1e-06 then do;
            weight_sol[k, o58] = Weight[o58].sol;
         end;
         else do;
            weight_sol[k, o58] = .;
         end;
      end;
   end;
   set EFFICIENT_GARAGES = {{o69 in GARAGES: efficiency_number[o69] >= 1}};
   set INEFFICIENT_GARAGES = GARAGES diff EFFICIENT_GARAGES;
   print garage_name efficiency_number;
   create data efficiency_data from [garage] garage_name efficiency_number;
   create data weight_data_dense from [inefficient_garage] = {{INEFFICIENT_GARAGES}} garage_name efficiency_number {efficient_garage in EFFICIENT_GARAGES} < col('w' || efficient_garage)=(weight_sol[inefficient_garage, efficient_garage]) >;
   create data weight_data_sparse from [i j] = {{{o83 in INEFFICIENT_GARAGES, o85 in EFFICIENT_GARAGES: weight_sol[o83, o85] ne .}}} weight_sol;
quit;