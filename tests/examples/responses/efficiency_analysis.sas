proc optmodel;
    set <str> INPUTS;
    read data INPUT_DATA into INPUTS=[input] ;
    set <str> OUTPUTS;
    read data OUTPUT_DATA into OUTPUTS=[output] ;
    set GARAGES;
    str garage_name {GARAGES};
    num input {INPUTS, GARAGES};
    num output {OUTPUTS, GARAGES};
    read data GARAGE_DATA into GARAGES=[_N_] garage_name {i in INPUTS} < input[i, _N_]=col(i) > {i in OUTPUTS} < output[i, _N_]=col(i) >;
    num k;
    num efficiency_number {GARAGES};
    num weight_sol {GARAGES, GARAGES};
    var Weight {{GARAGES}} >= 0;
    var Inefficiency >= 0;
    max Objective = Inefficiency;
    con input_con {o22 in INPUTS} : input[o22, k] - (sum {j in GARAGES} (input[o22, j] * Weight[j])) >= 0;
    con output_con {o34 in OUTPUTS} : sum {j in GARAGES} (output[o34, j] * Weight[j]) - output[o34, k] * Inefficiency >= 0;
    cofor {o47 in GARAGES} do;
        k = o47;
        solve;
        efficiency_number[k] = (1) / (Inefficiency.sol);
        for {o59 in GARAGES} do;
            if Weight[o59].sol > 1e-06 then do;
                weight_sol[k, o59] = Weight[o59].sol;
            end;
            else do;
                weight_sol[k, o59] = .;
            end;
        end;
    end;
    set EFFICIENT_GARAGES = {{o70 in GARAGES: efficiency_number[o70] >= 1}};
    set INEFFICIENT_GARAGES = GARAGES diff EFFICIENT_GARAGES;
    print garage_name efficiency_number;
    create data efficiency_data from [garage] garage_name efficiency_number;
    create data weight_data_dense from [inefficient_garage] = {{INEFFICIENT_GARAGES}} garage_name efficiency_number {efficient_garage in EFFICIENT_GARAGES} < col('w' || efficient_garage)=(weight_sol[inefficient_garage, efficient_garage]) >;
    create data weight_data_sparse from [i j] = {{{o84 in INEFFICIENT_GARAGES, o86 in EFFICIENT_GARAGES: weight_sol[o84, o86] ne .}}} weight_sol;
quit;